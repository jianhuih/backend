## 6.1 总览

### 知识面
####　基础数据结构
string（支持数字类型）、list、set、zset和hash

#### 常用命令
流水线：可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性

事务：watch、multi和exec命令结合（需要注意的是redis事务不具有原子性，前面失败后后面会继续执行而不是回滚）。所以一般需要使用watch命令配合：watch命令可用于监视key ，如果在事务执行之前这些 key 被其他命令所改动，那么事务将被打断

过期：expire

#### 数据过期策略
redis 提供6种数据淘汰策略：
1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6. no-enviction（驱逐）：禁止驱逐数据

注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。
　　
使用策略规则：
1. 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru
2. 如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random

#### 持久化
快照和aof

#### replica
同步过程：第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录下来，待完成后将rdb文件全量同步到replica节点，replica节点将该rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到replica节点进行重放就完成了同步过程。

需要注意的是，redis中replica节点默认是不能对外提供服务，仅仅是一个冷备；也可以配置提供读功能以实现读写分离

#### 集群
Redis采用区中心的设计方案，通过虚拟16384个slot，将每个key映射到每一个具体的slot上，而每个redis节点可以负责管理一定数量的slot。

##### 客户端访问
在单机模式下，Redis对请求的处理很简单。Key存在的话，就执行请求中的操作；Key不存在的话，就告诉客户端Key不存在。然而在集群模式下，因为涉及到请求重定向和Slot迁移，所以对请求的处理变得很复杂，流程如下：
1. 首先检查key所在slot是否属于当前node：计算crc16(key) % 16384得到slot，查询clusterState.slots负责slot的结点指针，与myself指针比较
2. 若不属于，则响应MOVED错误重定向客户端
3. 若属于且key存在，则直接操作，返回结果给客户端
4. 若key不存在，检查该slot是否迁出中？(clusterState.migrating_slots_to)
5. 若slot迁出中，返回ASK错误重定向客户端到迁移目的服务器上
6. 若slot未迁出，检查slot是否导入中？(clusterState.importing_slots_from)
7. 若slot导入中且有ASKING标记，则直接操作
8. 否则响应MOVED错误重定向客户端

#### 数据迁移
迁移数据的大致流程：首先需要确定哪些slot需要被迁移到目标节点，然后获取slot中key，将slot中的key全部迁移到目标节点，然后向集群所有主节点广播slot（数据）全部迁移到了目标节点。

#### 单线程模型
epoll模型，单线程处理客户端的连接和读写请求

### 常见应用
1. 分布式锁：超时特性（set命令）、锁的获取以及释放
2. 队列：
3. 延时队列：list和zset

### 常见问题

#### 缓存和数据库双写一致性问题
一致性问题还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。

如果不要求强一致性，则可以首先采取正确更新策略，先更新数据库，再删缓存。其次因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。

#### 缓冲穿透
一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，则去后端系统查找（比如DB）。如果key对应的value是不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。
1. 对查询结果为空的情况也进行缓存，缓存时间设置短一点。
2. 对不合法的key进行过滤，比如利用布隆过滤器key是否合法，不合法直接返回。

#### 缓冲雪崩
大量的key在同一时间过期。
1. 一般需要在时间上加一个随机值，使得过期时间分散一些。

#### 并发Key竞争问题

#### 大key迁移

